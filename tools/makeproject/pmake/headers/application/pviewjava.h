const char PVIEWJAVA_STR[] = 
"/*\n"
" * Copyright 2012-2014 Future Interface. All rights reserved.\n"
" * This software is licensed under the terms of the MIT license.\n"
" */\n"
"package com.fi.tech;\n"
"\n"
"import android.app.ActivityManager;\n"
"import android.app.Activity;\n"
"import android.content.Context;\n"
"\n"
"import android.graphics.Rect;\n"
"import android.graphics.PixelFormat;\n"
"import android.opengl.GLSurfaceView;\n"
"import android.os.PowerManager;\n"
"import android.util.Log;\n"
"import android.view.KeyEvent;\n"
"import android.view.MotionEvent;\n"
"\n"
"import javax.microedition.khronos.egl.EGL10;\n"
"import javax.microedition.khronos.egl.EGLConfig;\n"
"import javax.microedition.khronos.egl.EGLContext;\n"
"import javax.microedition.khronos.egl.EGLDisplay;\n"
"import javax.microedition.khronos.opengles.GL10;\n"
"\n"
"import java.util.ArrayList;\n"
"import java.util.List;\n"
"\n"
"/**\n"
" * TODO: Clean up the file.\n"
" */\n"
"public class PView extends GLSurfaceView {\n"
"	private static final String TAG = \"Paper3D\";\n"
"	private Activity activity;\n"
"\n"
"	// public static final int ES1 = 1;\n"
"	// public static final int ES2 = 2;\n"
"	private static final int CURSOR_STATE_DOWN = 0; // < finger down.\n"
"	private static final int CURSOR_STATE_STATIONARY = 1; // < finger still.\n"
"	private static final int CURSOR_STATE_MOVE = 2; // < finger move.\n"
"	private static final int CURSOR_STATE_UP = 3; // < finger up.\n"
"	private ArrayList<Runnable> queue = new ArrayList<Runnable>();\n"
"\n"
"	private PContext mContext = null;\n"
"\n"
"	/**\n"
"	 * @param activity\n"
"	 * @param contextName\n"
"	 */\n"
"	public PView(Activity activity, String contextName) {\n"
"		this(activity, %s, false, contextName);\n"
"	}\n"
"\n"
"	/**\n"
"	 * @param activity\n"
"	 * @param multisamples \n"
"	 * @param translucent\n"
"	 * @param contextName\n"
"	 */\n"
"	public PView(Activity activity, int multisamples, boolean translucent,\n"
"			String contextName) {\n"
"		super(activity);\n"
"\n"
"		this.activity = activity;\n"
"\n"
"		mContext = new PContext(contextName);\n"
"\n"
"		listServices(activity);\n"
"\n"
"		// Comment out the following line to use GLES 1.1\n"
"		setEGLContextFactory(new ContextFactory());\n"
"\n"
"		if (translucent) {\n"
"			// By default GLSurfaceView will create a PixelFormat.RGB_565 format\n"
"			// surface, override that here.\n"
"			getHolder().setFormat(PixelFormat.TRANSLUCENT);\n"
"			setZOrderOnTop(true);\n"
"		}\n"
"\n"
"		setEGLConfigChooser(new ConfigChooser(multisamples, translucent));\n"
"		setRenderer(new Renderer(this));\n"
"		// setPreserveEGLContextOnPause(true);\n"
"	}\n"
"\n"
"	public void quit() {\n"
"		activity.runOnUiThread(new Runnable() {\n"
"			public void run() {\n"
"				activity.finish();\n"
"			}\n"
"		});\n"
"	}\n"
"\n"
"	public void queueEvent(Runnable runnable) {\n"
"		synchronized (this) {\n"
"			queue.add(runnable);\n"
"		}\n"
"	}\n"
"\n"
"	public void handleQueuedEvents() {\n"
"		synchronized (this) {\n"
"			for (int i = 0; i < queue.size(); ++i) {\n"
"				Runnable runnable = queue.get(i);\n"
"				super.queueEvent(runnable);\n"
"			}\n"
"			queue.clear();\n"
"		}\n"
"	}\n"
"\n"
"	/**\n"
"	 * @param context\n"
"	 */\n"
"	private void listServices(Context context) {\n"
"		// ActivityManager am =\n"
"		// (ActivityManager)this.getSystemService(ACTIVITY_SERVICE);\n"
"		ActivityManager am = (ActivityManager) context\n"
"				.getSystemService(context.ACTIVITY_SERVICE);\n"
"\n"
"		List<ActivityManager.RunningServiceInfo> rs = am.getRunningServices(50);\n"
"\n"
"		for (int i = 0; i < rs.size(); i++) {\n"
"			ActivityManager.RunningServiceInfo rsi = rs.get(i);\n"
"			Log.i(TAG, \"Process \" + rsi.process + \" with component \"\n"
"					+ rsi.service.getClassName());\n"
"		}\n"
"	}\n"
"\n"
"	/**\n"
"	 * prevent the screen from going to sleep. Set this in constructor of the\n"
"	 * view\n"
"	 * \n"
"	 * @param context\n"
"	 */\n"
"	public void setWakeLock(Context context) {\n"
"		PowerManager powermanager = (PowerManager) context\n"
"				.getSystemService(Context.POWER_SERVICE);\n"
"		wl = powermanager.newWakeLock(PowerManager.SCREEN_DIM_WAKE_LOCK,\n"
"				\"My Tag\");\n"
"		wl.acquire();\n"
"	}\n"
"\n"
"	private PowerManager.WakeLock wl;\n"
"\n"
"	/**\n"
"	 * @return\n"
"	 */\n"
"	public int getScreenWidth() {\n"
"		return getWidth();\n"
"	}\n"
"\n"
"	/**\n"
"	 * @return\n"
"	 */\n"
"	public int getScreenHeight() {\n"
"		return getHeight();\n"
"	}\n"
"\n"
"	/**\n"
"	 * \n"
"	 * @return\n"
"	 */\n"
"	public int accelerometerAvailable() {\n"
"		return 0;\n"
"	}\n"
"\n"
"	/**\n"
"	 * @return\n"
"	 */\n"
"	public float getAccelerationX() {\n"
"		return 0;\n"
"	}\n"
"\n"
"	/**\n"
"	 * @return\n"
"	 */\n"
"	public float getAccelerationY() {\n"
"		return 0;\n"
"	}\n"
"\n"
"	/**\n"
"	 * @return\n"
"	 */\n"
"	public float getAccelerationZ() {\n"
"		return 0;\n"
"	}\n"
"\n"
"	/**\n"
"	 * @return\n"
"	 */\n"
"	public float[] getAcceleration() {\n"
"		float[] a = { 0.f, 0.f, 0.f };\n"
"		return a;\n"
"	}\n"
"\n"
"	/**\n"
"     *\n"
"     */\n"
"	private static class ContextFactory implements\n"
"			GLSurfaceView.EGLContextFactory {\n"
"		private static int EGL_CONTEXT_CLIENT_VERSION = 0x3098;\n"
"\n"
"		public EGLContext createContext(EGL10 egl, EGLDisplay display,\n"
"				EGLConfig eglConfig) {\n"
"			Log.i(TAG, \"creating OpenGL ES 2.0 context\");\n"
"			checkEglError(\"Before eglCreateContext\", egl);\n"
"			int[] attrib_list = { EGL_CONTEXT_CLIENT_VERSION, 2, EGL10.EGL_NONE };\n"
"			EGLContext context = egl.eglCreateContext(display, eglConfig,\n"
"					EGL10.EGL_NO_CONTEXT, attrib_list);\n"
"			checkEglError(\"After eglCreateContext\", egl);\n"
"\n"
"			// Do not resume or initialize here, cause the context is not set as\n"
"			// current. Instead, do that in onSurfaceCreated(),\n"
"			// which ensures that the surface is current.\n"
"\n"
"			return context;\n"
"		}\n"
"\n"
"		public void destroyContext(EGL10 egl, EGLDisplay display,\n"
"				EGLContext context) {\n"
"			egl.eglDestroyContext(display, context);\n"
"		}\n"
"	}\n"
"\n"
"	/**\n"
"	 * @param prompt\n"
"	 * @param egl\n"
"	 */\n"
"	private static void checkEglError(String prompt, EGL10 egl) {\n"
"		int error;\n"
"		while ((error = egl.eglGetError()) != EGL10.EGL_SUCCESS) {\n"
"			Log.e(TAG, String.format(\"%%s: EGL error: 0x%%x\", prompt, error));\n"
"		}\n"
"	}\n"
"\n"
"	/**\n"
"     *\n"
"     */\n"
"	private static class ConfigChooser implements\n"
"			GLSurfaceView.EGLConfigChooser {\n"
"		private int[] s_configAttribs;\n"
"\n"
"		/*\n"
"		 * public ConfigChooser() { this(2, false); } public ConfigChooser(int\n"
"		 * ES_version) { this(ES_version, false); }\n"
"		 */\n"
"\n"
"		/**\n"
"		 * @param multisamples\n"
"		 * @param translucent\n"
"		 */\n"
"		public ConfigChooser(int multisamples, boolean translucent) {\n"
"			int component_size = EGL10.EGL_DONT_CARE;\n"
"			if (translucent) {\n"
"				// translucent surface needs always 8 bits per component.\n"
"				// From Android SDK:\n"
"				// The exact format of a TRANSLUCENT surface is device\n"
"				// dependent, but it will be a 32-bit-per-pixel surface with 8\n"
"				// bits per component.\n"
"				component_size = 8;\n"
"			}\n"
"\n"
"			if (multisamples > 1) {\n"
"\n"
"				int[] conf = { EGL10.EGL_SAMPLES, multisamples, EGL10.EGL_SAMPLE_BUFFERS,\n"
"						1, EGL10.EGL_RED_SIZE, component_size,\n"
"						EGL10.EGL_GREEN_SIZE, component_size,\n"
"						EGL10.EGL_BLUE_SIZE, component_size,\n"
"						EGL10.EGL_DEPTH_SIZE, 16, EGL10.EGL_RENDERABLE_TYPE, 4,\n"
"						EGL10.EGL_STENCIL_SIZE, 8, EGL10.EGL_NONE };\n"
"				s_configAttribs = conf;\n"
"\n"
"			} else {\n"
"\n"
"				int[] conf = { EGL10.EGL_SAMPLES, 0, EGL10.EGL_SAMPLE_BUFFERS,\n"
"						0, EGL10.EGL_RED_SIZE, component_size,\n"
"						EGL10.EGL_GREEN_SIZE, component_size,\n"
"						EGL10.EGL_BLUE_SIZE, component_size,\n"
"						EGL10.EGL_DEPTH_SIZE, 16, EGL10.EGL_RENDERABLE_TYPE, 4,\n"
"						EGL10.EGL_STENCIL_SIZE, 8, EGL10.EGL_NONE };\n"
"				s_configAttribs = conf;\n"
"\n"
"			}\n"
"		}\n"
"\n"
"		/**\n"
"		 * @param egl\n"
"		 * @param display\n"
"		 * @return\n"
"		 */\n"
"		public EGLConfig chooseConfig(EGL10 egl, EGLDisplay display) {\n"
"			int[] num_config = new int[1];\n"
"			EGLConfig[] config = new EGLConfig[1];\n"
"			egl.eglChooseConfig(display, s_configAttribs, config, 1, num_config);\n"
"\n"
"			return config[0];\n"
"		}\n"
"	}\n"
"\n"
"	/**\n"
"     *\n"
"     */\n"
"	private class Renderer implements GLSurfaceView.Renderer {\n"
"		PView view;\n"
"\n"
"		Renderer(PView fiView) {\n"
"			this.view = fiView;\n"
"		}\n"
"\n"
"		/**\n"
"		 * @param gl\n"
"		 */\n"
"		public void onDrawFrame(GL10 gl) {\n"
"			if (mContext.isInitialized()) {\n"
"				view.handleQueuedEvents();\n"
"\n"
"				if (!mContext.update()) {\n"
"					Log.i(TAG, \"Terminating application now\");\n"
"					view.quit();\n"
"				}\n"
"			}\n"
"		}\n"
"\n"
"		/**\n"
"		 * @param gl\n"
"		 * @param width\n"
"		 * @param height\n"
"		 */\n"
"		public void onSurfaceChanged(GL10 gl, int width, int height) {\n"
"			Log.v(TAG, \"SurfaceChanged (GLSurfaceView.Renderer)\");\n"
"\n"
"			if (mContext.isInitialized()) {\n"
"				mContext.resize(width, height);\n"
"				if (width > height) {\n"
"					mContext.orientationChange(PContext.SCREEN_ORIENTATION_LANDSCAPE);\n"
"				} else {\n"
"					mContext.orientationChange(PContext.SCREEN_ORIENTATION_PORTRAIT);\n"
"				}\n"
"			}\n"
"		}\n"
"\n"
"		/**\n"
"		 * @param gl\n"
"		 * @param config\n"
"		 */\n"
"		public void onSurfaceCreated(GL10 gl, EGLConfig config) {\n"
"			Log.v(TAG, \"SurfaceCreated (GLSurfaceView.Renderer)\");\n"
"\n"
"			if (!mContext.isInitialized()) {\n"
"				mContext.initialize(getScreenWidth(), getScreenHeight());\n"
"			} else if (mContext.isPaused()) {\n"
"				mContext.resume();\n"
"			}\n"
"		}\n"
"	}\n"
"\n"
"	@Override\n"
"	public void onResume() {\n"
"		super.onResume();\n"
"	}\n"
"\n"
"	@Override\n"
"	public void onPause() {\n"
"		// FIXME: We should call GLSurfaceView.onPause() before call\n"
"		// PContext.pause(), because\n"
"		// GLThread is still running now. If we don't pause GLThread,\n"
"		// PContext::update and PContext::pause\n"
"		// will cross-run and crash randomly.\n"
"		// Notice that GLSurfaceView.onPause() do not pause GLThread immediately\n"
"		// on Android 4.3.\n"
"		// And actually, we should not make GL calls here.\n"
"		// Leave these comments so that we can fix it later.\n"
"		queueEvent(new Runnable() {\n"
"			public void run() {\n"
"				if (mContext.isInitialized() && !mContext.isPaused()) {\n"
"					// Pause application here, we're getting called from a right\n"
"					// thread.\n"
"					// Note that there's no context set as current, so we can't\n"
"					// make GL calls.\n"
"					mContext.pause();\n"
"					activity.runOnUiThread(new Runnable() {\n"
"						public void run() {\n"
"							pause();\n"
"						}\n"
"					});\n"
"				}\n"
"			}\n"
"		});\n"
"	}\n"
"\n"
"	private void pause() {\n"
"		super.onPause();\n"
"	}\n"
"\n"
"	public void onDestroy() {\n"
"		mContext.deinitialize();\n"
"	}\n"
"\n"
"	/**\n"
"	 * @param gainFocus\n"
"	 * @param direction\n"
"	 * @param previouslyFocusedRect\n"
"	 */\n"
"	@Override\n"
"	protected void onFocusChanged(boolean gainFocus, int direction,\n"
"			Rect previouslyFocusedRect) {\n"
"		if (mContext.isInitialized()) {\n"
"			mContext.focusEvent(gainFocus);\n"
"		}\n"
"\n"
"		super.onFocusChanged(gainFocus, direction, previouslyFocusedRect);\n"
"	}\n"
"\n"
"	/**\n"
"	 * @param keyCode\n"
"	 * @param event\n"
"	 * @return\n"
"	 */\n"
"	@Override\n"
"	public boolean onKeyDown(final int keyCode, KeyEvent event) {\n"
"		onKeyEvent(keyCode, event);\n"
"\n"
"		return super.onKeyDown(keyCode, event);\n"
"	}\n"
"\n"
"	/**\n"
"	 * @param keyCode\n"
"	 * @param event\n"
"	 * @return\n"
"	 */\n"
"	@Override\n"
"	public boolean onKeyUp(final int keyCode, KeyEvent event) {\n"
"		onKeyEvent(keyCode, event);\n"
"\n"
"		return super.onKeyUp(keyCode, event);\n"
"	}\n"
"\n"
"	/**\n"
"	 * Internal key handler, same for up and down.\n"
"	 * \n"
"	 * @param keyCode\n"
"	 * @param event\n"
"	 */\n"
"	private void onKeyEvent(final int keyCode, KeyEvent event) {\n"
"		final int touchState;\n"
"		final long timeStamp = event.getEventTime();\n"
"		switch (event.getAction()) {\n"
"		case KeyEvent.ACTION_DOWN:\n"
"			touchState = 0;\n"
"			break;\n"
"		case KeyEvent.ACTION_MULTIPLE:\n"
"			touchState = 2;\n"
"			break;\n"
"		default:\n"
"		case KeyEvent.ACTION_UP:\n"
"			touchState = 1;\n"
"			break;\n"
"		}\n"
"		// The touch event is queued and will be forwarded to P before the next\n"
"		// update\n"
"		queueEvent(new Runnable() {\n"
"			public void run() {\n"
"				mContext.keyEvent(keyCode, touchState, timeStamp);\n"
"			}\n"
"		});\n"
"	}\n"
"\n"
"	/**\n"
"	 * @param event\n"
"	 * @return\n"
"	 */\n"
"	@Override\n"
"	public boolean onTrackballEvent(MotionEvent event) {\n"
"		// TODO: send keyEvents to P\n"
"\n"
"		return super.onTrackballEvent(event);\n"
"	}\n"
"\n"
"	/**\n"
"	 * @param event\n"
"	 * @return\n"
"	 */\n"
"	@Override\n"
"	public boolean onTouchEvent(final MotionEvent originalEvent) {\n"
"		final MotionEvent event = MotionEvent.obtain(originalEvent);\n"
"		final int pointerCount = event.getPointerCount();\n"
"		final int cursorIndex;\n"
"		final int cursorState;\n"
"		final int state;\n"
"\n"
"		int cursorIndexLocal = -1; /* Match all pointers. */\n"
"		int action = event.getAction() & MotionEvent.ACTION_MASK;\n"
"		;\n"
"		int pointerIndex = (event.getAction() & MotionEvent.ACTION_POINTER_ID_MASK) >> MotionEvent.ACTION_POINTER_ID_SHIFT;\n"
"\n"
"		if (action == MotionEvent.ACTION_DOWN) {\n"
"			cursorState = CURSOR_STATE_DOWN;\n"
"			state = 0;\n"
"		} else if (action == MotionEvent.ACTION_MOVE) {\n"
"			cursorState = CURSOR_STATE_MOVE;\n"
"			state = 1;\n"
"		} else if ((action & MotionEvent.ACTION_POINTER_DOWN) == MotionEvent.ACTION_POINTER_DOWN) {\n"
"			cursorState = CURSOR_STATE_DOWN;\n"
"			// cursorIndexLocal = event.findPointerIndex(action &\n"
"			// MotionEvent.ACTION_POINTER_ID_MASK);\n"
"			cursorIndexLocal = pointerIndex;\n"
"			state = 1;\n"
"		} else if ((action & MotionEvent.ACTION_POINTER_UP) == MotionEvent.ACTION_POINTER_UP) {\n"
"			cursorState = CURSOR_STATE_UP;\n"
"			// cursorIndexLocal = event.findPointerIndex(action &\n"
"			// MotionEvent.ACTION_POINTER_ID_MASK);\n"
"			cursorIndexLocal = pointerIndex;\n"
"			state = 1;\n"
"		} else /* Default. */\n"
"		{\n"
"			cursorState = CURSOR_STATE_UP;\n"
"			state = 2;\n"
"		}\n"
"\n"
"		cursorIndex = cursorIndexLocal;\n"
"\n"
"		// The touch event is queued and will be forwarded to engine before the\n"
"		// next update\n"
"		queueEvent(new Runnable() {\n"
"			public void run() {\n"
"				long touchEvent = mContext.touchEvent(pointerCount, state);\n"
"\n"
"				for (int i = 0; (i < pointerCount); ++i) {\n"
"					int touchState;\n"
"\n"
"					if ((cursorIndex < 0) || (cursorIndex == i)) {\n"
"						touchState = cursorState;\n"
"					} else {\n"
"						touchState = CURSOR_STATE_STATIONARY;\n"
"					}\n"
"					mContext.touchCursor(touchEvent, i, event.getPointerId(i),\n"
"							event.getX(i), event.getY(i), event.getPressure(i),\n"
"							event.getSize(i), touchState, event.getEventTime());\n"
"				}\n"
"\n"
"				event.recycle();\n"
"			}\n"
"		});\n"
"\n"
"		return true;\n"
"	}\n"
"}\n"
;
